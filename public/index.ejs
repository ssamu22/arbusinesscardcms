<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin Dashboard</title>

    <link rel = "icon" href = "/images/temporary.jpg" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@yaireo/tagify/dist/tagify.css"
    />
    <link rel="stylesheet" href="/styles//user/home.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

  </head>
  <body>
    <div class="container-fluid">
      <div class="row">
        <!-- Sidebar -->
        <%- include('../resources/views/pages/user/partials/sidenav.ejs') %>

        <!-- Main content -->
        <main class="col-md-9 col-lg-9 px-md-2 main-content">
          <!-- Content Section -->
          <%- include('../resources/views/pages/user/components/overview.ejs')
          %>
        </main>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify"></script>
    <script>
      const sidebar = document.querySelector('.sidebar');
      const mainContent = document.querySelector('.main-content');
      const sidebarToggle = document.getElementById('sidebarToggle');

      sidebarToggle.addEventListener('click', () => {
      sidebar.classList.toggle('collapsed');
      mainContent.classList.toggle('expanded');
});
      // Navigation handling
      document.addEventListener("DOMContentLoaded", function () {
        const navLinks = document.querySelectorAll(".sidebar .nav-link");
        const mainContent = document.querySelector(".main-content");

        navLinks.forEach((link) => {
          link.addEventListener("click", function (e) {
            const targetSection = this.getAttribute("data-section");

            // Check if the link is the logout link
            if (!targetSection) {
              // Allow the default behavior (navigate to logout)
              return;
            }

            e.preventDefault();

            // Update active states for nav links
            navLinks.forEach((l) => l.classList.remove("active"));
            this.classList.add("active");

            // Dynamically load the content for the clicked section
            loadContent(targetSection);
          });
        });

        // Function to fetch the content from the server
        function loadContent(section) {
          fetch(`/home/${section}`) // Assumes you have a route for /load/:section
            .then((response) => response.text())
            .then((html) => {
              mainContent.innerHTML = html; // Inject the HTML into the main content
              if (section === "overview") {
                initializeOverview();
              } else if (section === "achievements") {
                initializeAchievements();
              } else if (section === "organizations") {
                initializeOrganizations();
              } else if (section === "contacts") {
                initializeContacts();
              } else if (section === "schedule") {
                initializeSchedule();
              } else if (section === "about-lpu-c") {
                initializeLPU();
              } else if (section === "change-password") {
                initializeChangePassword();
              }
            })
            .catch((error) => {
              console.error("Error loading content:", error);
            });
        }
        // overview page javascript functions
        function initializeOverview() {
          let tagify;

          // Fetch current introduction from the server and populate the textarea
          async function fetchDetails() {
            console.log("Fetching details");
            const response = await fetch("/api/details");
            const data = await response.json();
            console.log(data);

            document.getElementById("introduction").value = data.introduction;
            document.getElementById("position").value = data.position;
            document.getElementById("profile-picture").src = data.image_url;

            let fieldsInput = document.getElementById("researchFields");
            tagify = new Tagify(fieldsInput, {
              delimiters: ",", // Tags are separated by commas
              maxTags: 10, // Optional limit
              editTags: true, // Allow users to edit tags
            });

            tagify.addTags(data.fields);
          }

          // Fetch departments and populate dropdown
          async function fetchDepartments() {
            const response = await fetch("/api/departments");
            const departments = await response.json();

            const dropdown = document.getElementById("departmentDropdown");
            departments.forEach((department) => {
              const option = document.createElement("option");
              option.value = department.department_id;
              option.textContent = department.department_name;
              dropdown.appendChild(option);
            });

            // Set the selected department based on the logged-in user (session info)
            const currentDepartmentId = "<%= user.department_id %>"; // Assuming you pass session info from the backend
            dropdown.value = currentDepartmentId;
          }

          fetchDetails();
          fetchDepartments();

          document.getElementById("profile-img").addEventListener("change", (evt) => {
              const file = evt.target.files[0];
              if (file) {
                  const reader = new FileReader();
                  reader.onload = function(e) {
                      document.getElementById("profile-picture").src = e.target.result;
                  };
                  reader.readAsDataURL(file);
              }
          });

          async function uploadImage(file, namePrefix) {
            const formData = new FormData();
            const extension = file.name.split(".").pop(); // Extract file extension
            const fileName = `${namePrefix}.${extension}`; // Generate file name

            // Determine the bucket based on the type of image
            const bucket = "assets/employeeImages";

            formData.append("file", file);
            formData.append("bucket", bucket);
            formData.append("fileName", fileName);

            console.log("Uploading image: ", formData);

            try {
              const response = await fetch("/api/information/image", {
                method: "POST",
                body: formData,
              });

              if (response.ok) {
                return await response.json(); // Returns { bucket, fileName, url }
              } else {
                console.error("Failed to upload image:", response.statusText);
              }
            } catch (error) {
              console.error("Error uploading image:", error);
            }
          }

          document
            .getElementById("saveProfile")
            .addEventListener("click", async function (event) {
              event.preventDefault(); // Prevent form from submitting immediately

              // Show a confirmation alert before submitting
              if (confirm("Are you sure you want to update your profile?")) {
                const form = document.getElementById("profileForm");
                const formData = new FormData(form);

                const profilePic = document.getElementById("profile-img").files[0];

                if (profilePic) {
                  const imageData = await uploadImage(profilePic, `profile`);
                  formData.append("image_id", imageData.image_id);
                }

                // Convert form data to JSON
                const data = {};
                formData.forEach((value, key) => {
                  data[key] = value;
                });

                try {
                  const response = await fetch("/update-profile", {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify(data),
                  });

                  const result = await response.json();

                  if (response.ok) {
                    alert(result.message); // Show success message
                    window.location.href = "/home"; // Redirect to home after success
                  } else {
                    alert("Error: " + result.message); // Show error message
                  }
                } catch (error) {
                  console.error("Error updating profile", error);
                  alert("An error occurred while updating the profile.");
                }
              }
            });
        }
        // achievements page javascript functions
        function initializeAchievements() {
          const achievementsList = document.getElementById("achievements-list");
          const achievementFilter =
            document.getElementById("achievement-filter");
          const addAchievementBtn = document.getElementById(
            "add-achievement-btn"
          );
          const achievementModal = new bootstrap.Modal(
            document.getElementById("achievementModal")
          );
          const achievementForm = document.getElementById("achievement-form");
          const saveAchievementBtn =
            document.getElementById("save-achievement");
          const closeAchievementBtn =
            document.getElementById("close-achievement");
          let achievementIcons = {};
          let achievements = [];

          let isEditing = false;
          let editAchievementId = null;

          // Fetch achievements from the server and render them
          async function fetchAchievements() {
            try {
              const response = await fetch("/api/achievements");
              const data = await response.json();
              console.log(data);
              achievements = data; // Store fetched entries

              if (achievements.length > 0) {
                renderAchievements(); // Render the fetched entries
              }
              
            } catch (error) {
              console.error("Error fetching achievements:", error);
            }
          }

          async function fetchAchievementTypes(containerName) {
            const container = document.getElementById(containerName);
            try {
              const response = await fetch("/api/achievement-types");
              const data = await response.json();

              // Clear the container first in case of re-fetching
              container.innerHTML = "";

              if (containerName === "achievement-filter") {
                // Add the 'All' option at the beginning
                const allOption = document.createElement("option");
                allOption.value = "all"; // The value could be empty or something like 'all'
                allOption.textContent = "All Achievements"; // Display text for the 'All' option
                container.appendChild(allOption);
              }

              // Create and append option elements for each achievement type
              data.forEach((type) => {
                const option = document.createElement("option"); // Create an option element
                const name = type.name;
                option.value = name; // Set the value attribute
                option.setAttribute("data-achievement-id", type.achievement_id);

                option.textContent =
                  name.charAt(0).toUpperCase() + name.slice(1); // Set the display text
                container.appendChild(option); // Append the option to the select tag

                achievementIcons[name] = type.icon; // Store icon as a value in the object with name as key
              });
            } catch (error) {
              console.error("Error fetching achievement types:", error);
            }
          }

          window.editAchievement = function (id) {
            const achievement = achievements.find(
              (a) => a.achievement_id === id
            );
            openAchievementModal("edit", achievement);
          };

          window.deleteAchievement = async function (id) {
            const isConfirmed = confirm(
              "Are you sure you want to delete this achievement?"
            );
            if (!isConfirmed) return;

            const entryData = {
              achievement_id: id,
            };

            try {
              const response = await fetch(`/api/achievement/delete`, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(entryData), // Send the entry data to the backend
              });

              if (response.ok) {
                alert("Achievement deleted successfully!");
                achievements = achievements.filter(
                  (a) => a.achievement_id !== id
                ); // Remove the deleted achievement from the list
                renderAchievements(); // Re-render the updated achievements list
              } else {
                const error = await response.json();
                alert("Error: " + error.message);
              }
            } catch (error) {
              console.error("Error deleting achievement:", error);
              alert(
                "An error occurred while trying to delete the achievement."
              );
            }
          };

          function renderAchievements(filter = "all") {
            const filteredAchievements =
              filter === "all"
                ? achievements
                : achievements.filter((a) => a.achievement_type === filter);

            achievementsList.innerHTML = filteredAchievements
              .map(
                (achievement, index) => `
                              <div class="card mb-3 ${
                                index % 2 === 0 ? "bg-light" : "bg-white"
                              }">
                                  <div class="card-body">
                                      <div class="row">
                                          <div class="col-2 col-md-1 d-flex align-items-center justify-content-center">
                                              ${
                                                achievementIcons[
                                                  achievement.achievement_type
                                                ]
                                              }
                                          </div>
                                          <div class="col-8 col-md-9">
                                              <h5 class="card-title">${
                                                achievement.title
                                              }</h5>
                                              <p class="card-text">${
                                                achievement.description
                                              }</p>
                                              <span class="badge bg-secondary">${
                                                achievement.date_achieved
                                              }</span>
                                          </div>
                                          <div class="col-2 col-md-2 d-flex align-items-center justify-content-end">
                                              <!-- Edit and Delete Icons -->
                                              <i class="bi bi-pencil-square mx-2 edit-icon" title="Edit" onclick="editAchievement(${
                                                achievement.achievement_id
                                              })" style="cursor: pointer;"></i>
                                              <i class="bi bi-trash-fill delete-icon" title="Delete" onclick="deleteAchievement(${
                                                achievement.achievement_id
                                              })" style="cursor: pointer;"></i>
                                          </div>
                                      </div>
                                  </div>
                              </div>
                          `
              )
              .join("");
          }

          function openAchievementModal(action, achievement = null) {
            // Reset the form first
            achievementForm.reset();

            const modalElement = document.getElementById("achievementModal");

            if (action === "edit") {
              isEditing = true;
              editAchievementId = achievement.achievement_id; // Store the ID for updating
              modalElement.querySelector(".modal-title").textContent =
                "Edit Achievement";
              modalElement.querySelector("#save-achievement").textContent =
                "Update Changes";

              // Populate the fields with the existing achievement data
              document.getElementById("achievement-title").value =
                achievement.title;
              document.getElementById("achievement-description").value =
                achievement.description;
              document.getElementById("achievement-year").value =
                achievement.date_achieved;

              // Set the achievement type
              const achievementTypeSelect =
                document.getElementById("achievement-type");
              fetchAchievementTypes("achievement-type").then(() => {
                const option = Array.from(achievementTypeSelect.options).find(
                  (opt) => opt.value === achievement.achievement_type.toString()
                );
                if (option) option.selected = true;
              });
            } else {
              isEditing = false;
              editAchievementId = null;
              modalElement.querySelector(".modal-title").textContent =
                "Add Achievement";
              modalElement.querySelector("#save-achievement").textContent =
                "Add Achievement";

              // Fetch the types for creating a new achievement
              fetchAchievementTypes("achievement-type");
            }

            achievementModal.show();
          }

          achievementFilter.addEventListener("change", function () {
            renderAchievements(this.value);
          });

          addAchievementBtn.addEventListener("click", function () {
            achievementModal.show();
            fetchAchievementTypes("achievement-type");
          });

          saveAchievementBtn.addEventListener("click", async function () {
            const title = document.getElementById("achievement-title").value;
            const description = document.getElementById(
              "achievement-description"
            ).value;
            const date_achieved =
              document.getElementById("achievement-year").value;
            const achievement_id = editAchievementId;

            // Get the selected option from the achievement-type select
            const achievementTypeSelect =
              document.getElementById("achievement-type");
            const selectedOption =
              achievementTypeSelect.options[
                achievementTypeSelect.selectedIndex
              ];
            const achievement_type = selectedOption.dataset.achievementId;

            let newAchievement = {};

            if (isEditing) {
              newAchievement = {
                achievement_id,
                title,
                description,
                date_achieved,
                achievement_type,
              };
            } else {
              newAchievement = {
                title,
                description,
                date_achieved,
                achievement_type,
              };
            }

            const isConfirmed = confirm(
              "Are you sure you want to submit this entry?"
            );
            if (!isConfirmed) return;

            saveAchievementBtn.disabled = true;
            closeAchievementBtn.disabled = true;
            saveAchievementBtn.textContent = "Loading...";

            try {
              const method = isEditing ? "PUT" : "POST";
              console.log(method);
              const url = "/api/achievements";

              // Send the data to the backend
              const response = await fetch(url, {
                method,
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(newAchievement),
              });

              const result = await response.json();

              if (response.ok) {
                alert(
                  isEditing
                    ? "Entry updated successfully!"
                    : "Entry created successfully!"
                );
                if (isEditing) {
                  // Update the achievements array
                  const index = achievements.findIndex(
                    (a) => a.achievement_id === editAchievementId
                  );
                  achievements[index] = result;
                } else {
                  achievements.push(result);
                }

                renderAchievements();
                achievementModal.hide();
                achievementForm.reset();
              } else {
                alert("Error: " + result.error);
              }
            } catch (err) {
              console.error("Error:", err);
              alert("An error occurred while saving the entry.");
            } finally {
              isEditing = false;
              editAchievementId = null;
              saveAchievementBtn.disabled = false;
              closeAchievementBtn.disabled = false;
              saveAchievementBtn.textContent = "Add Achievement";
            }
          });

          // Button to open the modal for adding a new achievement
          addAchievementBtn.addEventListener("click", () =>
            openAchievementModal("add")
          );

          fetchAchievementTypes("achievement-filter"); // Store achievement types for filters
          fetchAchievements();
        }

        // organizations page javascript functions
        // function initializeOrganizations() {
        //   const addOrgBtn = document.getElementById("add-org-btn");
        //   const orgList = document.getElementById("org-list");
        //   const orgForm = document.getElementById("org-form");
        //   const orgModal = new bootstrap.Modal(
        //     document.getElementById("orgModal")
        //   );
        //   let organizations = [];
        //   let currentOrgId = null;

        //   addOrgBtn.addEventListener("click", () => {
        //     currentOrgId = null;
        //     orgForm.reset();
        //     document.getElementById("orgModalLabel").textContent =
        //       "Add Organization";
        //     orgForm.querySelector('button[type="submit"]').textContent =
        //       "Add Organization";
        //     orgModal.show();
        //   });

        //   orgForm.addEventListener("submit", function (e) {
        //     e.preventDefault();
        //     const name = document.getElementById("org-name").value;
        //     const role = document.getElementById("org-role").value;
        //     const description =
        //       document.getElementById("org-description").value;
        //     const imageFile = document.getElementById("org-image").files[0];

        //     if (currentOrgId) {
        //       const index = organizations.findIndex(
        //         (org) => org.id === currentOrgId
        //       );
        //       organizations[index] = {
        //         ...organizations[index],
        //         name,
        //         role,
        //         description,
        //       };
        //       if (imageFile) {
        //         const reader = new FileReader();
        //         reader.onload = function (e) {
        //           organizations[index].imageUrl = e.target.result;
        //           renderOrganizations();
        //         };
        //         reader.readAsDataURL(imageFile);
        //       } else {
        //         renderOrganizations();
        //       }
        //     } else {
        //       const newOrg = { id: Date.now(), name, role, description };
        //       if (imageFile) {
        //         const reader = new FileReader();
        //         reader.onload = function (e) {
        //           newOrg.imageUrl = e.target.result;
        //           organizations.push(newOrg);
        //           renderOrganizations();
        //         };
        //         reader.readAsDataURL(imageFile);
        //       } else {
        //         organizations.push(newOrg);
        //         renderOrganizations();
        //       }
        //     }

        //     orgModal.hide();
        //   });

        //   function renderOrganizations() {
        //     orgList.innerHTML = "";
        //     organizations.forEach((org) => {
        //       const col = document.createElement("div");
        //       col.className = "col";
        //       col.innerHTML = `
        //                           <div class="card h-100">
        //                               ${
        //                                 org.imageUrl
        //                                   ? `<img src="${org.imageUrl}" class="card-img-top" alt="${org.name}">`
        //                                   : ""
        //                               }
        //                               <div class="card-body">
        //                                   <h5 class="card-title">${
        //                                     org.name
        //                                   }</h5>
        //                                   <h6 class="card-subtitle mb-2 text-muted">${
        //                                     org.role
        //                                   }</h6>
        //                                   <p class="card-text">${
        //                                     org.description
        //                                   }</p>
        //                                   <button class="btn btn-outline-primary btn-sm me-2 edit-org" data-id="${
        //                                     org.id
        //                                   }">Edit</button>
        //                                   <button class="btn btn-outline-danger btn-sm delete-org" data-id="${
        //                                     org.id
        //                                   }">Delete</button>
        //                               </div>
        //                           </div>
        //                       `;
        //       orgList.appendChild(col);
        //     });

        //     // Add event listeners for edit and delete buttons
        //     document.querySelectorAll(".edit-org").forEach((btn) => {
        //       btn.addEventListener("click", function () {
        //         const orgId = parseInt(this.getAttribute("data-id"));
        //         const org = organizations.find((o) => o.id === orgId);
        //         if (org) {
        //           currentOrgId = org.id;
        //           document.getElementById("org-name").value = org.name;
        //           document.getElementById("org-role").value = org.role;
        //           document.getElementById("org-description").value =
        //             org.description;
        //           document.getElementById("orgModalLabel").textContent =
        //             "Edit Organization";
        //           orgForm.querySelector('button[type="submit"]').textContent =
        //             "Update Organization";
        //           orgModal.show();
        //         }
        //       });
        //     });

        //     document.querySelectorAll(".delete-org").forEach((btn) => {
        //       btn.addEventListener("click", function () {
        //         const orgId = parseInt(this.getAttribute("data-id"));
        //         organizations = organizations.filter((org) => org.id !== orgId);
        //         renderOrganizations();
        //       });
        //     });
        //   }
        // }

        function initializeOrganizations() {
          const addOrgBtn = document.getElementById("add-org-btn");
          const orgList = document.getElementById("org-list");
          const orgForm = document.getElementById("org-form");
          const orgModal = new bootstrap.Modal(
            document.getElementById("orgModal")
          );
          const orgTypeFilter = document.getElementById("org-type-filter");

          let organizations = []; // Replace this with data fetching logic from your database
          let currentOrgId = null;
          let isEditing = false;

          const currentYear = new Date().getFullYear();
          const startYear = 1950; // Start year for the dropdowns
          const dateJoinedDropdown = document.getElementById("org-date-joined");
          const dateActiveDropdown = document.getElementById("org-date-active");

          // Populate year dropdowns
          for (let year = currentYear; year >= startYear; year--) {
            const option = document.createElement("option");
            option.value = year;
            option.textContent = year;
            dateJoinedDropdown.appendChild(option);

            const activeOption = option.cloneNode(true);
            dateActiveDropdown.insertBefore(
              activeOption,
              dateActiveDropdown.firstChild
            );
          }

          // Ensure "Present" is the first option in Date Active
          const presentOption = document.createElement("option");
          presentOption.value = "present";
          presentOption.textContent = "Present";
          dateActiveDropdown.insertBefore(
            presentOption,
            dateActiveDropdown.firstChild
          );

          async function fetchOrganizations() {
            try {
              const response = await fetch("/api/organizations");
              const data = await response.json();
              organizations = data;
              if (organizations.length > 0) {
                renderOrganizations();
              }
            } catch (err) {
              console.error("Error:", err);
              alert("An error occurred while fetching organizations.");
            }
          }

          // Handle add organization button click
          addOrgBtn.addEventListener("click", () => {
            currentOrgId = null;
            orgForm.reset();
            document.getElementById("orgModalLabel").textContent =
              "Add Organization";
            orgForm.querySelector('button[type="submit"]').textContent =
              "Add Organization";
            orgModal.show();
          });

          orgForm.addEventListener("submit", async function (e) {
            e.preventDefault();

            const name = document.getElementById("org-name").value.trim();
            const type = document.getElementById("org-type").value.trim();
            const category = document
              .getElementById("org-category")
              .value.trim();
            const description = document
              .getElementById("org-description")
              .value.trim();
            const position = document
              .getElementById("org-position")
              .value.trim();
            const date_joined =
              document.getElementById("org-date-joined").value;
            const date_active =
              document.getElementById("org-date-active").value;

            const bannerFile = document.getElementById("org-banner").files[0];
            const logoFile = document.getElementById("org-image").files[0];

            let orgData = {
              org_name: name,
              org_type: type,
              image_id: null,
              category: category,
              description: description,
              banner_id: null,
              position: position,
              date_joined: date_joined,
              date_active: date_active,
            };

            // Check if editing an existing organization
            if (currentOrgId) {
              if (confirm("Are you sure you want to save changes?")) {
                createOrganization(orgData, bannerFile, logoFile);
              }
            } else {
              // Create a new organization entry
              if (confirm("Are you sure you want to save this entry?")) {
                createOrganization(orgData, bannerFile, logoFile);
              }
            }

            orgModal.hide();
          });

          // Upload image to the server
          async function uploadImage(file, namePrefix) {
            const formData = new FormData();
            const extension = file.name.split(".").pop(); // Extract file extension
            const fileName = `${namePrefix}.${extension}`; // Generate file name

            // Determine the bucket based on the type of image
            const bucket = namePrefix.includes("banner")
              ? "assets/orgBannerImages"
              : "assets/employeeOrgsImages";

            formData.append("file", file);
            formData.append("bucket", bucket);
            formData.append("fileName", fileName);

            console.log("Uploading image: ", formData);

            try {
              const response = await fetch("/api/organizations/image", {
                method: "POST",
                body: formData,
              });

              if (response.ok) {
                return await response.json(); // Returns { bucket, fileName, url }
              } else {
                console.error("Failed to upload image:", response.statusText);
              }
            } catch (error) {
              console.error("Error uploading image:", error);
            }
          }

          // Add organization to the database
          async function createOrganization(data, bannerFile, logoFile) {
            try {
              const organizationData = data;

              // Upload the banner if provided
              if (bannerFile) {
                const bannerImage = await uploadImage(
                  bannerFile,
                  `${data.org_name}_banner`
                );
                organizationData.banner_id = bannerImage.image_id;
              }

              // Upload the logo if provided
              if (logoFile) {
                const logoImage = await uploadImage(
                  logoFile,
                  `${data.org_name}_logo`
                );
                organizationData.image_id = logoImage.image_id;
              }

              if (currentOrgId != null) {
                organizationData.organization_id = currentOrgId;
              }

              // Send the organization data to the backend
              const response = await fetch("/api/organizations", {
                method: isEditing ? "PUT" : "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(organizationData),
              });

              if (response.ok) {
                const newOrg = await response.json(); // Backend should return the created or updated organization

                if (isEditing) {
                  // Update the existing entry in the organizations array
                  const orgIndex = organizations.findIndex(
                    (org) => org.organization_id === newOrg.organization_id
                  );
                  if (orgIndex !== -1) {
                    organizations[orgIndex] = newOrg;
                  }
                } else {
                  // Add the new organization
                  organizations.push(newOrg);
                }

                alert(
                  `Organization ${
                    isEditing ? "updated" : "added"
                  } successfully!`
                );
                isEditing = false;
                renderOrganizations();
              } else {
                const errorMessage = await response.text();
                console.error(
                  "Error adding/updating organization:",
                  errorMessage
                );
                alert(
                  `Failed to ${
                    isEditing ? "update" : "add"
                  } the organization. Error: ${response.statusText}`
                );
              }
            } catch (error) {
              console.error(
                "An error occurred while adding/updating the organization:",
                error
              );
              alert(`An unexpected error occurred: ${error.message}`);
            }
          }

          // Render organizations list
          function renderOrganizations() {
            const selectedType = orgTypeFilter.value;
            orgList.innerHTML = "";

            organizations
              .filter(
                (org) => selectedType === "all" || org.org_type === selectedType
              )
              .forEach((org) => {
                const col = document.createElement("div");
                col.className = "col";
                col.innerHTML = `
                                      <div class="card h-100 position-relative">
                                          <!-- Banner Image -->
                                          <img src="${
                                            org.banner_url ||
                                            "/default-image.png"
                                          }"
                                              class="card-img-top"
                                              alt="${org.org_name}"
                                              style="height: 200px; object-fit: cover;">

                                          <!-- Circular Logo -->
                                          <div class="logo-container position-absolute">
                                              <img src="${
                                                org.logo_url ||
                                                "/default-logo.png"
                                              }"
                                                  alt="${org.org_name} Logo"
                                                  class="logo-circle">
                                          </div>

                                          <!-- Card Body -->
                                          <div class="card-body">
                                              <h5 class="card-title">${
                                                org.org_name
                                              }</h5>
                                              <h6 class="card-subtitle mb-2 text-muted">${
                                                org.org_type
                                              }</h6>
                                              <p class="card-text description"
                                              title="${
                                                org.description || "N/A"
                                              }">
                                              ${
                                                org.description
                                                  ? org.description.length > 100
                                                    ? org.description.slice(
                                                        0,
                                                        100
                                                      ) + "..."
                                                    : org.description
                                                  : "N/A"
                                              }
                                              </p>
                                              <p class="card-text">Position: ${
                                                org.position || "N/A"
                                              }</p>
                                              <p class="card-text">Category: ${
                                                org.category || "N/A"
                                              }</p>
                                              <p class="card-text">Date: ${
                                                org.date_joined || "N/A"
                                              } - ${
                  org.date_active || "Present"
                }</p>

                                              <button class="btn btn-outline-primary btn-sm me-2 edit-org" data-id="${
                                                org.organization_id
                                              }">Edit</button>
                                              <button class="btn btn-outline-danger btn-sm delete-org" data-id="${
                                                org.organization_id
                                              }">Delete</button>
                                          </div>
                                      </div>
                                  `;
                orgList.appendChild(col);
              });

            // Event listeners for edit and delete buttons
            document.querySelectorAll(".edit-org").forEach((btn) => {
              btn.addEventListener("click", function () {
                const orgId = parseInt(this.getAttribute("data-id"));
                const org = organizations.find(
                  (o) => o.organization_id === orgId
                );
                if (org) {
                  isEditing = true;
                  currentOrgId = org.organization_id;
                  document.getElementById("org-name").value = org.org_name;
                  document.getElementById("org-type").value = org.org_type;
                  document.getElementById("org-description").value =
                    org.description;
                  document.getElementById("org-position").value = org.position;
                  document.getElementById("org-category").value = org.category;
                  document.getElementById("org-date-joined").value =
                    org.date_joined;
                  document.getElementById("org-date-active").value =
                    org.date_active;
                  document.getElementById("org-banner").value = "";
                  document.getElementById("org-image").value = "";
                  document.getElementById("orgModalLabel").textContent =
                    "Edit Organization";
                  document.getElementById("submit-btn").textContent =
                    "Update Organization";
                  orgModal.show();
                }
              });
            });

            document.querySelectorAll(".delete-org").forEach((btn) => {
              btn.addEventListener("click", async function () {
                const orgId = parseInt(this.getAttribute("data-id"));

                const isConfirmed = confirm(
                  "Are you sure you want to delete this organization?"
                );
                if (!isConfirmed) return;

                const entryData = {
                  organization_id: orgId,
                };

                try {
                  const response = await fetch(`/api/organization/delete`, {
                    method: "POST",
                    headers: {
                      "Content-Type": "application/json",
                    },
                    body: JSON.stringify(entryData), // Send the entry data to the backend
                  });

                  if (response.ok) {
                    alert("Organization deleted successfully!");
                    organizations = organizations.filter(
                      (org) => org.organization_id !== orgId
                    ); // Remove the deleted organization from the list
                    renderOrganizations(); // Re-render the updated achievements list
                  } else {
                    const error = await response.json();
                    alert("Error: " + error.message);
                  }
                } catch (error) {
                  console.error("Error deleting organization:", error);
                  alert(
                    "An error occurred while trying to delete the organization."
                  );
                }

                organizations = organizations.filter(
                  (org) => org.organization_id !== orgId
                );
                renderOrganizations();
              });
            });
          }

          // Event listener for the filter dropdown
          orgTypeFilter.addEventListener("change", renderOrganizations);
          fetchOrganizations();
        }
        // contacts page javascript functions
        // function initializeContacts() {
        //   const editToggle = document.getElementById("edit-toggle");
        //   const contactForm = document.getElementById("contact-form");
        //   const contactName = document.getElementById("contact-name");
        //   const contactTitle = document.getElementById("contact-title");
        //   const consultationHours =
        //     document.getElementById("consultation-hours");
        //   const socialMediaList = document.getElementById("social-media-list");
        //   const addSocialMediaBtn = document.getElementById("add-social-media");
        //   // organizations page javascript functions

        //   // contacts page javascript functions

        //   // schedule page javascript functions
        // }

        function initializeContacts() {
          const editToggle = document.getElementById("edit-toggle");
          const contactForm = document.getElementById("contact-form");
          const contactName = document.getElementById("contact-name");
          const contactTitle = document.getElementById("contact-title");

          const socialMediaList = document.getElementById("social-media-list");
          const addSocialMediaBtn = document.getElementById("add-social-media");

          let editMode = false;

          let contactInfo = {
            name: "",
            title: "",
            phone: "",
            landline: "",
            email: "",
            socialMedia: [],
          };

          async function fetchContacts() {
            console.log("Fetching details");
            try {
              const response = await fetch("/api/contacts");
              const data = await response.json();
              console.log(data);

              const contacts = data.contacts;

              contactInfo.name = data.name;
              contactInfo.title = data.position;

              if(contacts){
                if(contacts.contact_id){
                  contactInfo.contactId = contacts.contact_id;
                }

                // Update the fields in contactInfo based on the fetched contact data
                contactInfo.phone = contacts.phone_number || "";
                contactInfo.landline = contacts.landline || "";
                contactInfo.email = contacts.email || "";

                // Update social media URLs
                contactInfo.socialMedia = [
                  { platform: "facebook", url: contacts.facebook_url || "" },
                  { platform: "instagram", url: contacts.instagram_url || "" },
                  { platform: "linkedin", url: contacts.linkedin_url || "" },
                ];
              }

              renderContactInfo();
              renderSocialMedia();

              console.log("Updated contact info:", contactInfo);
            } catch (error) {
              console.error("Error fetching contacts:", error);
            }
          }

          const socialMediaIcons = {
            facebook: '<i class="bi bi-facebook"></i>',
            instagram: '<i class="bi bi-instagram"></i>',
            linkedin: '<i class="bi bi-linkedin"></i>',
            // github: '<i class="bi bi-github"></i>',
            // youtube: '<i class="bi bi-youtube"></i>',
            // twitter: '<i class="bi bi-twitter"></i>',
          };

          function renderContactInfo() {
            contactName.textContent = contactInfo.name;
            contactTitle.textContent = contactInfo.title;
            document.getElementById("phone").value = contactInfo.phone;
            // document.getElementById("landline").value = contactInfo.landline;
            document.getElementById("email").value = contactInfo.email;
          }

          function renderSocialMedia() {
            // Define static platforms
            const platforms = ["facebook", "instagram", "linkedin"];
          
            // Initialize the list with static input fields
            socialMediaList.innerHTML = platforms
              .map(
                (platform, index) => `
                  <li class="list-group-item d-flex align-items-center">
                    <div class="me-2">${socialMediaIcons[platform] || ""}</div>
                    <span class="me-2" style="width: 150px;">
                      ${platform.charAt(0).toUpperCase() + platform.slice(1)}
                    </span>
                    <input type="url" class="form-control" placeholder="Enter your ${
                      platform.charAt(0).toUpperCase() + platform.slice(1)
                    } URL" value="" data-index="${index}" ${!editMode ? "disabled" : ""}>
                  </li>
                `
              )
              .join("");
          
            // Populate the retrieved data from the database
            if (contactInfo.socialMedia && Array.isArray(contactInfo.socialMedia)) {
              contactInfo.socialMedia.forEach((social) => {
                // Find the corresponding input for the platform
                const input = socialMediaList.querySelector(
                  `input[data-index="${platforms.indexOf(social.platform.toLowerCase())}"]`
                );
                if (input) {
                  input.value = social.url || ""; // Set the value from the database
                }
              });
            }
          }

          async function toggleEditMode() {
            editMode = !editMode;
            editToggle.textContent = editMode ? "Save" : "Edit";
            // addSocialMediaBtn.style.display = editMode ? 'block' : 'none';

            const inputs = contactForm.querySelectorAll("input, select");
            inputs.forEach((input) => (input.disabled = !editMode));

            if (!editMode) {
              const isConfirmed = confirm(
                "Are you sure you want to save changes?"
              );
              if (!isConfirmed) {
                editToggle.disabled = false; // Re-enable if saving was cancelled
                return;
              }

              editToggle.disabled = true; // Disable the button while saving
              editToggle.textContent = "Saving..."; // Change button text to "Loading..." while saving

              try {
                await saveContactInfo(); // Call the save function
                editToggle.textContent = "Edit"; // Revert button text to "Edit" after successful save
              } catch (error) {
                console.error("Failed to save contact info:", error);
                alert("An error occurred while saving. Please try again.");
                editToggle.textContent = "Save"; // Keep "Save" text in case of error, to retry
              }
            }

            editToggle.disabled = false; // Re-enable the button after save is complete
            renderSocialMedia();
          }

          async function saveContactInfo() {
            // Gather data from contactInfo
            const updatedContactInfo = {
              ...contactInfo.contactId && { contact_id: contactInfo.contactId },
              phone_number: contactInfo.phone,
              landline: contactInfo.landline,
              email: contactInfo.email,
              facebook_url:
                contactInfo.socialMedia.find(
                  (social) => social.platform === "facebook"
                )?.url || "",
              instagram_url:
                contactInfo.socialMedia.find(
                  (social) => social.platform === "instagram"
                )?.url || "",
              linkedin_url:
                contactInfo.socialMedia.find(
                  (social) => social.platform === "linkedin"
                )?.url || "",
            };

            let errors = {};

            // console.log("New contact info: " + JSON.stringify(updatedSchedule));

            try {
              // Send the updated data to the backend
              const contactResponse = await fetch("/api/contacts", {
                method: "PUT",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(updatedContactInfo),
              });

              if (!contactResponse.ok) {
                throw new Error("Failed to save contact information");
                errors.contacts = "Failed to save contact information";
              }

              const updatedContacts = await contactResponse.json();
              console.log("Contact information saved:", updatedContacts);

              alert("Contact information saved successfully!");
            } catch (error) {
              console.error("Error saving contact information:", error);
              alert("An error occurred while saving the contact information.");
            }
          }

          editToggle.addEventListener("click", toggleEditMode);

          contactForm.addEventListener("change", function (e) {
            if (e.target.matches("#phone, #landline, #email")) {
              contactInfo[e.target.name] = e.target.value;
            }
          });

          socialMediaList.addEventListener("change", function (e) {
            if (e.target.matches("select, input")) {
              const index = parseInt(e.target.dataset.index);
              const field = e.target.tagName === "SELECT" ? "platform" : "url";
              contactInfo.socialMedia[index][field] = e.target.value;
            }
          });

          socialMediaList.addEventListener("click", function (e) {
            if (e.target.matches(".remove-social-media")) {
              const index = parseInt(e.target.dataset.index);
              contactInfo.socialMedia.splice(index, 1);
              renderSocialMedia();
            }
          });

          addSocialMediaBtn.addEventListener("click", function () {
            contactInfo.socialMedia.push({ platform: "facebook", url: "" });
            renderSocialMedia();
          });

          fetchContacts();
        }

        function initializeSchedule() {
          const consultationHours =
            document.getElementById("consultation-hours");
          const editConsultationHours = document.getElementById(
            "editConsultationHours"
          );
          const consultationTypes =
            document.getElementById("consultation-types");
          const editConsultationTypes = document.getElementById(
            "editConsultationTypes"
          );

          const daysOfWeek = [
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
          ];

          let editMode = false;

          let schedule = {
            consultationHours: daysOfWeek.map((day) => ({
              day,
              available: false,
              start_time: "09:00",
              end_time: "17:00",
              location: "",
            })),
            consultationTypes: [
              {
                consultation: "In-Person",
                description: "Consultation at the office",
              },
              {
                consultation: "Online",
                description: "Consultation via video call",
              },
              {
                consultation: "Phone",
                description: "Consultation via phone call",
              },
            ],
          };

          async function fetchSchedule() {
            renderDefaultConsultationHours();
            try {
              const response = await fetch("/api/schedule");
              const data = await response.json();

              const { consultationHours, consultationTypes } = data;

              console.log(data);

              consultationHours.forEach((entry) => {
                const dayIndex = daysOfWeek.indexOf(entry.day); // Find the index of the day in daysOfWeek
                if (dayIndex !== -1) {
                  schedule.consultationHours[dayIndex] = {
                    schedule_id: entry.schedule_id,
                    day: entry.day,
                    available: entry.available,
                    start_time: entry.start_time,
                    end_time: entry.end_time,
                    location: entry.location || "",
                  };
                }
              });

              schedule.consultationTypes = consultationTypes.map((type) => ({
                contype_id: type.contype_id,
                consultation: type.consultation,
                description: type.description,
              }));

              console.log(schedule.consultationTypes);

              if (consultationHours) {
                populateConsultationHours(schedule.consultationHours);
              }
              if (consultationTypes) {
                populateConsultationTypes(schedule.consultationTypes);
              }

              // Update Consultation Types
              consultationTypes.forEach((type, index) => {
                const typeNameInput = document.getElementById(
                  `type-${index}-name`
                );
                const typeDescriptionInput = document.getElementById(
                  `type-${index}-description`
                );
                if (typeNameInput && typeDescriptionInput) {
                  typeNameInput.value = type.type_name;
                  typeDescriptionInput.value = type.type_description;
                }
              });
            } catch (error) {
              console.error("Error fetching schedule:", error);
            }
          }

          function renderDefaultConsultationHours() {
            consultationHours.innerHTML = schedule.consultationHours
              .map(
                (hour, index) => `
              <div class="row mb-2 align-items-center">
                  <div class="col-3">
                      <div class="form-check form-switch">
                          <input class="form-check-input" type="checkbox" id="available-${
                            hour.day
                          }"
                              ${hour.available ? "checked" : ""} ${
                  !editMode ? "disabled" : ""
                }
                              data-index="${index}" data-field="available">
                          <label class="form-check-label" for="available-${
                            hour.day
                          }">${hour.day}</label>
                      </div>
                  </div>
                  <div class="col-4">
                      <div class="input-group">
                          <input type="time" class="form-control" value="${
                            hour.start_time
                          }"
                              data-index="${index}" data-field="start_time"
                              ${!editMode || !hour.available ? "disabled" : ""}>
                          <span class="input-group-text">to</span>
                          <input type="time" class="form-control" value="${
                            hour.end_time
                          }"
                              data-index="${index}" data-field="end_time"
                              ${!editMode || !hour.available ? "disabled" : ""}>
                      </div>
                  </div>
                  <div class="col-5">
                      <div class="d-flex align-items-center">
                          <label class="form-check-label me-2" for="location-${
                            hour.day
                          }">Location:</label>
                          <input type="text" class="form-control" placeholder="No location set" id="location-${
                            hour.day
                          }" value="${hour.location}"
                              data-index="${index}" data-field="location"
                              ${!editMode ? "disabled" : ""}>
                      </div>
                  </div>
              </div>
          `
              )
              .join("");
          }

          function populateConsultationHours(data) {
            data.forEach((hour, index) => {
              const availableInput = document.querySelector(
                `#available-${hour.day}`
              );
              const startTimeInput = document.querySelector(
                `input[data-index="${index}"][data-field="start_time"]`
              );
              const endTimeInput = document.querySelector(
                `input[data-index="${index}"][data-field="end_time"]`
              );
              const locationInput = document.querySelector(
                `input[data-index="${index}"][data-field="location"]`
              );

              if (availableInput) {
                availableInput.checked = hour.available;
              }
              if (startTimeInput) {
                startTimeInput.value = hour.start_time;
              }
              if (endTimeInput) {
                endTimeInput.value = hour.end_time;
              }
              if (locationInput) {
                locationInput.value = hour.location || "";
              }
            });
          }

          function populateConsultationTypes(data) {
            // Iterate through the consultation types data
            data.forEach((type, index) => {
              // Select the name and description input fields for each consultation type
              const nameInput = document.querySelector(
                `#type-${index}-consultation`
              );
              const descriptionInput = document.querySelector(
                `#type-${index}-description`
              );

              // Populate the input fields with the corresponding data values
              if (nameInput) {
                nameInput.value = type.consultation || ""; // Default to empty string if no value is present
              }
              if (descriptionInput) {
                descriptionInput.value = type.description || ""; // Default to empty string if no value is present
              }
            });
          }

          editConsultationTypes.addEventListener("click", async () => {
            editMode = !editMode;

            editConsultationTypes.textContent = editMode ? "Save" : "Edit";

            document
              .querySelectorAll("#consultation-types input")
              .forEach((input) => {
                input.disabled = !editMode;
              });

            if (!editMode) {
              if (!confirm("Are you sure you want to save changes?")) return;

              editConsultationTypes.textContent = "Updating...";
              editConsultationTypes.disabled = true;

              try {
                await updateTypes();
                editConsultationTypes.textContent = "Edit"; // Revert button text to "Edit" after successful save
              } catch (error) {
                console.error("Failed to save contact info:", error);
                alert("An error occurred while saving. Please try again.");
                editConsultationTypes.textContent = "Save"; // Keep "Save" text in case of error, to retry
              }
            }

            editConsultationTypes.disabled = false; // Re-enable the button after save is complete
          });

          editConsultationHours.addEventListener("click", async () => {
            editMode = !editMode;

            editConsultationHours.textContent = editMode ? "Save" : "Edit";

            document
              .querySelectorAll("#consultation-hours .form-check-input")
              .forEach((checkbox) => {
                const index = checkbox.dataset.index;

                // Find associated inputs
                const startTimeInput = document.querySelector(
                  `input[data-index="${index}"][data-field="start_time"]`
                );
                const endTimeInput = document.querySelector(
                  `input[data-index="${index}"][data-field="end_time"]`
                );
                const locationInput = document.querySelector(
                  `input[data-index="${index}"][data-field="location"]`
                );

                // Enable/disable fields based on edit mode and checkbox state
                const enableFields = editMode && checkbox.checked;
                checkbox.disabled = !editMode; // Checkboxes are editable only in edit mode
                startTimeInput.disabled = !enableFields;
                endTimeInput.disabled = !enableFields;
                locationInput.disabled = !enableFields;

                // Update fields dynamically when checkbox is toggled
                checkbox.addEventListener("change", () => {
                  const isChecked = checkbox.checked;
                  startTimeInput.disabled = !isChecked;
                  endTimeInput.disabled = !isChecked;
                  locationInput.disabled = !isChecked;
                });
              });

            if (!editMode) {
              if (!confirm("Are you sure you want to save changes?")) {
                return;
              }

              editConsultationHours.textContent = "Updating...";
              editConsultationHours.disabled = true;

              try {
                await updateSchedule();
                editConsultationHours.textContent = "Edit"; // Revert button text to "Edit" after successful save
              } catch (error) {
                console.error("Failed to save consultation hours:", error);
                alert("An error occurred while saving. Please try again.");
                editConsultationHours.textContent = "Save"; // Keep "Save" text in case of error, to retry
              }
            }

            editConsultationHours.disabled = false; // Re-enable the button after save is complete
          });

          consultationHours.addEventListener("change", function (e) {
            const target = e.target;

            if (target.matches('input[type="checkbox"]')) {
              const index = parseInt(target.dataset.index);
              const available = target.checked;

              // Update the availability in the schedule object
              schedule.consultationHours[index].available = available;

              // Enable or disable related inputs dynamically
              const row = target.closest(".row");
              row
                .querySelectorAll(
                  'input[type="time"], input[data-field="location"]'
                )
                .forEach((input) => {
                  input.disabled = !available;
                });
            } else if (target.matches('input[type="time"]')) {
              const index = parseInt(target.dataset.index);
              const field = target.dataset.field;

              // Update the start_time or end_time in the schedule object
              schedule.consultationHours[index][field] = target.value;
            } else if (target.matches('input[data-field="location"]')) {
              const index = parseInt(target.dataset.index);

              // Update the location in the schedule object
              schedule.consultationHours[index].location = target.value;
            }
          });

          consultationTypes.addEventListener("change", function (e) {
            const target = e.target;

            // Determine which field was changed (name or description)
            if (
              target.matches(
                'input[id^="type-"][id$="-consultation"], input[id^="type-"][id$="-description"]'
              )
            ) {
              const index = parseInt(target.id.split("-")[1]); // Extract the index from the input ID
              const field = target.id.split("-")[2]; // Determine the field (name or description)

              // Update the corresponding consultation type data
              if (!schedule.consultationTypes[index]) {
                schedule.consultationTypes[index] = {}; // Ensure the slot exists if it's empty
              }
              schedule.consultationTypes[index][field] = target.value;

              // Enable or disable the inputs based on the data in schedule.consultationTypes
              const nameInput = document.querySelector(
                `#type-${index}-consultation`
              );
              const descriptionInput = document.querySelector(
                `#type-${index}-description`
              );

              // Enable fields if there is a name or description in the corresponding slot
              const hasData =
                schedule.consultationTypes[index].consultation ||
                schedule.consultationTypes[index].description;
              nameInput.disabled = !hasData;
              descriptionInput.disabled = !hasData;
            }
          });

          async function updateSchedule() {
            // Collect the updated schedule
            const updatedSchedule = schedule.consultationHours.map((hour) => {
              // Create an object without schedule_id initially
              const scheduleEntry = {
                day: hour.day,
                available: hour.available,
                start_time: hour.start_time,
                end_time: hour.end_time,
                location: hour.location || null,
              };

              // Conditionally add schedule_id only if it exists
              if (hour.schedule_id) {
                scheduleEntry.schedule_id = hour.schedule_id;
              }

              return scheduleEntry;
            });

            console.log(updatedSchedule);

            // Send the updated data to the backend
            const scheduleResponse = await fetch("/api/schedule/hours", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(updatedSchedule),
            });

            if (!scheduleResponse.ok) {
              throw new Error("Failed to save schedule");
            }

            const successSchedule = await scheduleResponse.json();
            console.log("Consultation hours saved:", successSchedule);
            alert("Consultation hours saved");
          }

          async function updateTypes() {
            // Collect the updated schedule
            const updatedTypes = schedule.consultationTypes.map((type) => {
              // Create an object without schedule_id initially
              const typeEntry = {
                consultation: type.consultation,
                description: type.description,
              };

              // Conditionally add schedule_id only if it exists
              if (type.contype_id) {
                typeEntry.contype_id = type.contype_id;
              }

              return typeEntry;
            });

            console.log(updatedTypes);

            // Send the updated data to the backend
            const typeResponse = await fetch("/api/schedule/types", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(updatedTypes),
            });

            if (!typeResponse.ok) {
              throw new Error("Failed to save consultation types");
            }

            const successTypes = await typeResponse.json();
            console.log("Consultation types saved:", successTypes);
            alert("Consultation types saved");
          }

          fetchSchedule();
        }
        function initializeLPU() {
          const uploadInput = document.getElementById("upload");
          const canvas = document.getElementById("histoEqCanvas");
          const ctx = canvas.getContext("2d");
          const submitCard = document.getElementById("submitBCard");
          const form = document.getElementById("uploadForm");
          const markerName = document.getElementById("marker-name");
          const markerId = document.getElementById("marker-id");
          uploadInput.addEventListener("change", (event) => {
            checkFields();
            handleFileSelect(event);
          });

          markerName.addEventListener("input", checkFields);
          markerId.addEventListener("input", checkFields);

          function checkFields() {
            nameIsFilled = markerName.value.trim() !== "";
            markerUploaded = uploadInput.files.length > 0;
            idIsFilled = markerId.value.trim() !== "" && !isNaN(markerId.value);

            submitCard.disabled = !(
              nameIsFilled &&
              markerUploaded &&
              idIsFilled
            );
          }

          form.addEventListener("submit", (event) => {
            event.preventDefault(); // Prevent the default form submission

            // Convert canvas to JPEG data URL
            const dataURL = canvas.toDataURL("image/jpeg"); // 'image/jpeg' format

            // Convert Data URL to Blob
            const [header, base64] = dataURL.split(",");
            const binary = atob(base64);
            const array = [];
            for (let i = 0; i < binary.length; i++) {
              array.push(binary.charCodeAt(i));
            }
            const blob = new Blob([new Uint8Array(array)], {
              type: "image/jpeg",
            });

            // Append the Blob to a FormData object
            const formData = new FormData();
            formData.append("name", markerName.value);
            formData.append("width", 6);
            formData.append("active_flag", true);
            formData.append(
              "application_metadata",
              JSON.stringify({
                Id: markerId.value,
              })
            );
            formData.append("image", blob, "canvas-image.jpg"); // Ensure the key is 'image'

            // Submit the form data using Fetch
            fetch(form.action, {
              method: form.method,
              body: formData,
            })
              .then((response) => {
                if (response.ok) {
                  alert("Marker successfully uploaded!");
                  return response.json();
                } else {
                  throw new Error("Failed to upload image");
                }
              })
              .then((data) => console.log("Image uploaded successfully:", data))
              .catch((error) => {
                alert("Marker already exists! Please upload another one.");
                console.error("Error uploading image:", error);
              });
          });

          function handleFileSelect(event) {
            canvas.style.display = "block";
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function (e) {
              const img = new Image();
              img.onload = function () {
                const originalData = getImageData(img);
                const histoEqData = histogramEqualization(originalData);

                drawEnhancedImage(histoEqData, "histoEqCanvas");

                addDownloadButton(
                  "histoEqCanvas",
                  "Download Histogram Equalized Image",
                  "histo-equalized.jpg"
                );
              };
              img.src = e.target.result;
            };

            const dataURL = canvas.toDataURL("image/jpeg"); // Get base64 data

            const blob = dataURLToBlob(dataURL); // Convert to Blob
            console.log(blob);
            reader.readAsDataURL(file);
          }
          function dataURLToBlob(dataURL) {
            const [header, base64] = dataURL.split(",");
            const binary = atob(base64);
            const array = [];
            for (let i = 0; i < binary.length; i++) {
              array.push(binary.charCodeAt(i));
            }
            return new Blob([new Uint8Array(array)], {
              type: header.split(":")[1].split(";")[0],
            });
          }
          function getImageData(img) {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
          }
          function drawEnhancedImage(imageData, canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext("2d");
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            ctx.putImageData(imageData, 0, 0);
          }

          function addDownloadButton(canvasId, buttonText, fileName) {
            const canvas = document.getElementById(canvasId);
            const button = document.createElement("button");
            button.textContent = buttonText;
            button.addEventListener("click", () =>
              downloadImage(canvas, fileName)
            );
            document.querySelector(".canvasDiv").appendChild(button);
          }

          function downloadImage(canvas, fileName) {
            const link = document.createElement("a");
            link.download = fileName;
            link.href = canvas.toDataURL("image/jpeg");
            link.click();
          }

          function histogramEqualization(imageData, blendRatio = 1) {
            const { data, width, height } = imageData;
            const histogram = new Array(256).fill(0);
            const cdf = new Array(256).fill(0);
            const equalizedData = new Uint8ClampedArray(data.length);

            // Calculate histogram
            for (let i = 0; i < data.length; i += 4) {
              const intensity = data[i]; // Grayscale
              histogram[intensity]++;
            }

            // Calculate cumulative distribution function (CDF)
            cdf[0] = histogram[0];
            for (let i = 1; i < 256; i++) {
              cdf[i] = cdf[i - 1] + histogram[i];
            }

            // Normalize CDF
            const minCDF = cdf[0];
            for (let i = 0; i < cdf.length; i++) {
              cdf[i] = Math.round(
                ((cdf[i] - minCDF) * 255) / (width * height - minCDF)
              );
            }

            // Apply equalization
            for (let i = 0; i < data.length; i += 4) {
              const intensity = data[i];
              equalizedData[i] =
                equalizedData[i + 1] =
                equalizedData[i + 2] =
                  Math.round(
                    blendRatio * cdf[intensity] + (1 - blendRatio) * intensity
                  );
              equalizedData[i + 3] = data[i + 3]; // Alpha channel
            }

            return new ImageData(equalizedData, width, height);
          }
        }

        function initializeChangePassword() {
          const formContainer = document.getElementById('changePasswordForm');

          const currentPassword = document.getElementById('currentPassword');
          const newPassword = document.getElementById('newPassword');
          const confirmPassword = document.getElementById('confirmPassword');

          window.resetChangePasswordForm = () => {
            formContainer.reset();
          }

          async function changePassword(){
            const oldPassword = currentPassword.value.trim();
            const updatedPassword = newPassword.value.trim();

            const passwordData = {
              oldPassword: oldPassword,
              newPassword: updatedPassword,
            };

            try {
              const response = await fetch("/change-password", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(passwordData),
              });

              const responseData = await response.json();
          
              if (!response.ok) {
                throw new Error(responseData.message || "Failed to change password");
              }
          
              console.log("Password successfully saved");
              alert("Password updated successfully!");
              resetChangePasswordForm();
            } catch (error) {
              console.error("Error saving password:", error);
              alert(error.message);
            }
          }

          formContainer.addEventListener('submit', async (e) => {
            e.preventDefault(); 

            if (newPassword.value.trim() !== confirmPassword.value.trim()) {
              alert("Confirm password does not match the new password!");
              return;
            }

            if (confirm("Do you want to save changes?")) {
              await changePassword();
            }

            
          });
        }

        initializeOverview();
      });
    </script>
    
  </body>
</html>
